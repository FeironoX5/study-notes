# От мечт об упрощений до необходимости усложнения

## Основные идеи лекции

Брет Виктор в лекции "Будущее программирования" описывает его как битву между безграничными возможностями компьютеров и консерватизмом человеческого мышления. Как программисты сопротивлялись переходу от двоичного кода к ассемблеру, так и потом сопротивлялись Фортрану.
В эти времена мощность компьютеров росла экспоненциально согласно закону Мура и сильно опрежала человеческое понимание програмирования. Такая среда, сложившаяся в 60-70х годах поспособствовала развитию необычных подходов, говорящих о том, что программирование перестанет быть инструкцией для машины и будет скорее похоже на взаимодействие с реальным миром. Вместо алгоритмов мы будем управлять данными напрямую, задавая цели и ограничения. Например, система Sketchpad из 1960-х позволяла рисовать идеальные геометрические фигуры через ряд динамических ограничений, а не ручное описание линий, сюда же Prolog и регулярные выражения — ранние примеры такого подхода. Помимо этого, важна ещё и репрезентация информации — вместо сплошного текста появятся интерактивные пространства, а параллельные вычисления заменят архаичные потоки и блокировки, опять же по примеру физических частиц. Виктор делает акцент на том, что важно прислушатся к этим нестандартным концепциям и что настоящей трагедией станет неспособность генерировать новые идеи в программировании. 

Идеи, представленные Виктором, для поразительно актуальны, многое действительно нашло применение в современном мире, но многое удивиляет меня сейчас как и его современников тогда. 
Особенно заметно, как воплотились в жизнь идеи визуального взаимодействия с данными: Figma, Notion, Excel — новые «Sketchpad», даже код пишется с применением визуальных приёмов, например, выделения цветом. И если первые часто пытаются имитировать физические объекты, то вторые скорее придумывают абсолютно новые, но удобные способы взаимодействия с текстом. Также, кажется что асинхронные модели — это уже реальность, к примеру Elixir. Но даже они не победили «потоки и блокировки», потому что сложность распределённых систем часто перевешивает преимущества новых парадигм. Prolog и регулярки доказали, что декларативный подход работает, но лишь узнонаправленно. Современные low-code платформы и AI-генераторы кода (например, GitHub Copilot) — это шаг в сторону «целевого» мышления, но они пока лишь помощники, а не замена.

Парадоксально, но сегодня мы сталкиваемся с ровно противоположной проблемой. Если тогда основным барьером было сопротивление новым идеям, то сейчас индустрия страдает от их переизбытка, взять область фронтенд, где регулярно появляются новые фреймворки, библиотеки и инструменты, вводящие новые концепции. На первый план выходит понимание фундаментальных принципов, позволяющих отличать шлак от полезного. 



Интересно отметить, что концепция "данные определяют код", о которой говорил Виктор, нашла свое яркое воплощение в современном языке Clojure. Этот лисподобный язык с его принципом гомоиконичности (код как данные) и акцентом на иммутабельные структуры полностью соответствует идеям Виктора о прямом манипулировании данными. Это замечательный пример того, как революционные идеи прошлого находят реализацию в современных технологиях.

В эпоху искусственного интеллекта возникает новая угроза — замена креативного мышления шаблонными решениями, сгенерированными ИИ. Это может усугубить проблему, о которой говорит Виктор, — потерю способности генерировать действительно новые идеи.

Подлинная инновация требует баланса между освоением существующих технологий и готовностью их переосмыслить. Как и в музыке, где каждый поджанр может содержать шедевры, в программировании разнообразие подходов не означает деградацию дисциплины — оно свидетельствует о ее зрелости и многогранности.